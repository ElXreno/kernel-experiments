Reapply and merge in Fedora changes

--- a/drivers/pci/pci.h	2009-02-25 20:16:13.000000000 +0000
+++ b/drivers/pci/pci.h	2009-02-25 20:40:21.000000000 +0000
@@ -111,9 +111,11 @@
 
 #ifdef CONFIG_PCI_MSI
 void pci_no_msi(void);
+void pci_yes_msi(void);
 extern void pci_msi_init_pci_dev(struct pci_dev *dev);
 #else
 static inline void pci_no_msi(void) { }
+static inline void pci_yes_msi(void) { }
 static inline void pci_msi_init_pci_dev(struct pci_dev *dev) { }
 #endif
 
diff --git a/arch/x86/pci/common.c b/arch/x86/pci/common.c
index 2202b62..f371fe8 100644
--- a/arch/x86/pci/common.c
+++ b/arch/x86/pci/common.c
@@ -432,6 +432,22 @@ int __init pcibios_init(void)
 		pci_cache_line_size = 64 >> 2;  /* K7 & K8 */
 	else if (c->x86 > 6 && c->x86_vendor == X86_VENDOR_INTEL)
 		pci_cache_line_size = 128 >> 2;	/* P4 */
+	if (c->x86_clflush_size != (pci_cache_line_size <<2))
+		printk(KERN_DEBUG "PCI: old code would have set cacheline "
+			"size to %d bytes, but clflush_size = %d\n",
+			pci_cache_line_size << 2,
+			c->x86_clflush_size);
+
+	/* Once we know this logic works, all the above code can be deleted. */
+	if (c->x86_clflush_size > 0) {
+		pci_cache_line_size = c->x86_clflush_size >> 2;
+		printk(KERN_DEBUG "PCI: pci_cache_line_size set to %d bytes\n",
+			pci_cache_line_size << 2);
+	} else {
+		pci_cache_line_size = 32 >> 2;
+		printk(KERN_DEBUG "PCI: Unknown cacheline size. Setting to 32 bytes\n");
+	}
+
 }
 
 int __init pcibios_init(void)
--- a/arch/x86/include/asm/mmu.h
+++ b/arch/x86/include/asm/mmu.h
@@ -7,6 +7,9 @@
 /*
  * The x86 doesn't have a mmu context, but
  * we put the segment information here.
+ *
+ * exec_limit is used to track the range PROT_EXEC
+ * mappings span.
  */
 typedef struct {
 	void *ldt;
--- a/arch/x86/include/asm/mmu.h
+++ b/arch/x86/include/asm/mmu.h
@@ -16,6 +19,10 @@
 #ifdef CONFIG_XEN
 	int has_foreign_mappings;
 #endif
+#ifdef CONFIG_X86_32
+	struct desc_struct user_cs;
+	unsigned long exec_limit;
+#endif
 } mm_context_t;
 
 #ifdef CONFIG_SMP
Date: Fri, 03 Dec 2010 21:48:34 +0100
From: Paolo Bonzini <pbonzini@redhat.com>
Subject: [PATCH xen/stable-2.6.32.x] fix ethtool_get_drvinfo NULL pointer dereference

Fixes the following crash on "ethtool -i":

BUG: unable to handle kernel NULL pointer dereference at 0000000000000148
IP: [<ffffffff813bcfe2>] ethtool_get_drvinfo+0x106/0x1a5
PGD d8040067 PUD d8041067 PMD 0
Oops: 0000 [#1] SMP
last sysfs file: /sys/devices/pci0000:00/0000:00:1c.0/0000:09:00.0/irq 
...
Call Trace:
[<ffffffff813bd298>] dev_ethtool+0x93/0x1153
[<ffffffff810dd957>] ? __alloc_pages_nodemask+0x122/0x62d
[<ffffffff810dd957>] ? __alloc_pages_nodemask+0x122/0x62d
[<ffffffff811ee21e>] ? avc_has_perm+0x5c/0x6e
[<ffffffff811158ad>] ? try_get_mem_cgroup_from_mm+0x39/0x49 
...
RIP  [<ffffffff813bcfe2>] ethtool_get_drvinfo+0x106/0x1a5 

The backport of 01414802 was incomplete.  This is the patch we are
using in RHEL6.

Reported-by: M A Young <m.a.young@durham.ac.uk>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Cc: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
---
 ethtool.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index ff35ce3..8ca3a26 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -211,9 +211,9 @@ static int ethtool_get_drvinfo(struct net_device *dev, void __user *useraddr)
 	} else {
 		/* code path for obsolete hooks */
 
-		if (ops->self_test_count)
+		if (ops && ops->self_test_count)
 			info.testinfo_len = ops->self_test_count(dev);
-		if (ops->get_stats_count)
+		if (ops && ops->get_stats_count)
 			info.n_stats = ops->get_stats_count(dev);
 	}
 	if (ops && ops->get_regs_len)

